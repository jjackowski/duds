# DUDS
C++ application level style access to low level hardware

This is a somewhat rushed release because I'm using it to make a gizmo to assit me with 
photographing the August 21, 2017 total solar eclipse. I've put some of the mainpage 
documentation here, but the real documentation is generated by Doxygen and Graphviz. You'll find 
some code that is unfinished; it is a work in progress.

# Distributed Update of Data from Something

A silly name, because I'm not good at making up names, that attempts to describe the ultimate 
goal for this family of libraries. At present, DUDS only has a single library with functionality 
for time and interfacing with hardware through the Linux kernel. It aspires to be a set of 
libraries that include functionality for representing measurements taken from hardware, sending 
that data over a network, and doing so in a multi-platform environment.

# Goals

- Be a well designed C++ happy library that is multi-platform where applicable.
- Take advantage of C++11.
- Support multi-threaded programs.
- Support dynamic resource usage.
- Favor correctness over performance.
- Favor flexibility and capability over ease of use.
- Consist of namespaces with well defined purposes that are as independent as sensible.
- Offer robust error reporting and handling.
- Have unambiguous time stamps.
- Track accuracy, precision, resolution, and origin of sample data.
- Have good reference documentation.
- Allow for internationalization support.

# Audience

The audience, users of the library, include:
- Intermediate and experienced C++ developers
- Developers who want to mix high-level application code with use of low-level gizmos

The audience is not intended to include:
- Beginning developers
- Developers unfamiliar with C++
- Developers making high performance applications
- Developers who avoid error handling

While it is not intentional to exclude people from using this library, the library isn't 
intended to be a perfect fit for everyone or every use. For instance, it isn't made with the 
goal of being super easy to use as a top priority, and the documentation assumes a familiarity 
with C++.

# Supported Platforms

Right now, only Linux. Hardware access is only tested on Raspberry Pis, but the library does 
build on AMD64, and the test program works fine on both. The hardware access code is not 
specific to the Raspberry Pi. I've been using Gentoo on the Raspberry Pis and have not tested 
Raspbian.

# Build

- [SCons](http://scons.org/) 2.3 or so (it isn't very picky about the version)
  - Python 2.7 to less than 3 (older versions possible with SCons 2.3.4 and older)
- Build configuration options: run "scons -h"
  - The configuration can be changed for one build by specifying an option as an argument to 
scons.
  - To keep a configuration saved, set variables with the same name of the configuration options 
in Python syntax in localbuildconfig.py in the same directory as SConstruct.
- gcc 5.4.x
  - gcc 4.8.2 may still work
  - gcc 6.x.y and newer are untested
- [Boost](http://www.boost.org/) version 1.62 or so
  - Some older versions may work down to 1.56
  - Boost libraries used:
    - Date time
    - Exception (header only)
    - Filesystem (optional)
    - Multiprecision (header only)
    - Serialization
    - Signals2 (header only)
    - System
    - Unit test framework (optional; used for test programs, not DUDS library)
    - Variant (header only)
  - Build configuration options include Boost directories and variations on the names of the 
Boost library binaries.
  - Default configuration is for a regular Boost build that is installed to default paths. This 
works on Gentoo Linux when Boost is installed by Portage.
  - Ubuntu needs build configuration setting BOOSTTAG= (equals empty string) given to SCons. 
This changes the expected name of the Boost libraries; Ubuntu does not use the default names 
from the Boost build.
- Build host
  - Linux
    - At least 1GB RAM if no swap space; more for parallel builds
      - I let loose a template monster; it has a big party during the build.
    - Raspberry Pi Models A, A+, B, B+, and Raspberry Pi Zero
      - More than half an hour.
      - Needs at least tens of megabytes of swap, or maybe 300MB or so if only 256MB of RAM are 
available.
    - Raspberry Pi 2
      - Around ten minutes without a parallel build. No swap space is needed when very little is 
running (no GUI), total RAM is reported as at least 896MB, and free RAM is 821MB. A very little 
swap space is needed when total RAM is 746MB.
      - About seven minutes with -j 2. Swap space is required, although not much is needed.
      - Under 5.5 minutes with -j 4.
    - x86 and AMD64/Intel 64/x86-64
      - Works fine; build times vary greatly and can be under a minute.

# Build targets

The default build target is the DUDS library. Sample programs are built with the "samples" 
target, and the tests program (one program right now) with the "tests" target. All those targets 
make debug builds. There is support for optimized builds, but they are untested. Build from the 
root directory of DUDS by running scons. The binaries will be placed in a directory under bin 
named for the target and build. For example:
- duds
  - bin
    - linux-armv6l-dbg
    - linux-armv6l-opt
    - linux-x86_64-dbg

There is currently no target for installation. Despite using Linux since 2001, I'm not really 
sure how software is typically installed.
