/*
 * This file is part of the DUDS project. It is subject to the BSD-style
 * license terms in the LICENSE file found in the top-level directory of this
 * distribution and at http://www.somewhere.org/somepath/license.html.
 * No part of DUDS, including this file, may be copied, modified, propagated,
 * or distributed except according to the terms contained in the LICENSE file.
 *
 * Copyright (C) 2018  Jeff Jackowski
 */
/**

@page DUDStools  Tools

@section DUDStoolsBppic  Bit-Per-Pixel Image Compiler

The Bit-Per-Pixel Image Compiler (bppic) takes image data written in a text file and produces either C++ source code with data for use with the @ref duds::hardware::devices::displays::BppImage::BppImage(const char*) "BppImage" class, or an image archive file for use with  @ref duds::hardware::devices::displays::BppImageArchive "BppImageArchive". The compiler is itself a C++ program.

@subsection DUDStoolsBppicSrc  Source file format

The source file format is intended to make it easy to represent simple images, but it does have a few peculiarities. There are three different parsing areas in the file: in-between areas, image headers, and image data.

@subsubsection DUDStoolsBppicSrcInBet  In-between areas

These are the areas of the file that do not have any image data. They consist only of whitespace and comments. All comments begin with a slash ('/'). If the slash is followed by an asterisk ('*'), the comment will continue until the two characters are found in reverse. These comments will be added to the output file. Otherwise, the comment will end at the end of the line and will not be added to the output file. Comments are not nested.

Comments may appear in the other two area types of the file as well.

@subsubsection DUDStoolsBppicSrcImgHdr  Image headers

These announce the start of an image. An image header starts in an in-between area with an alphabetic character. The character is the start of a valid C++ identifier that will name the image in the generated source code. It must be followed by any amount of any combination of whitespace and commas, then the width, followed by more whitespace and/or commas, and then the height. Following the height, all characters are ignored until an opening curly brace ('{'). That brace begins the image data.

@subsubsection DUDStoolsBppicSrcImgDat  Image data

Each pixel of the image is represented by a space for a clear (0) pixel, or by an alphabetic character or pound sign ('#') for a set (1) pixel. A slash ('/') starts a rest-of-line comment. Except for a comment, if any of these characters are encountered on a line, that line provides the next row of image data. A row of image data cannot extend to the next line in the text file. Any other characters encountered are ignored. This allows numbers to be added to assist with placing the pixels within the specified size of the image.

Characters for set pixels may not occur outside the image's width except inside a comment. Spaces, used for clear pixels, may occur outside the width; these will be ignored. Clear pixels do not need to pad out the width of the image. Unspecified pixels, both for width and height, will be clear. Characters for any pixels may not occur outside the height of the image.

The image is terminated with a closing curly brace ('}'). The text following it will be parsed as an in-between area.

@subsubsection DUDStoolsBppicSrcSamp  Sample source

The same image twice, first with few comments, then heavily commented.

@code
/* * (space between asterisks so Doxygen will let you see this) 
 * Tiny wireless LAN icon for use with HD44780 type text displays.
 */
WirelessLAN
5, 8
	01234 {
0	 // space in front of comment
1	 
2	XXX
3	   X
4	XX  X
5	  X X
6	X X X
}

/* 
 * This comment will be found in C++ output files. The double-slash
 * comments will not.
 */
WirelessLAN_commented  // the name, must be unique in the source file
5, 8                   // width then height
    Completely ignored text. Better style-wise to use comments anyway.
    // No space before the start of the next comment, or it will be the
    // first row of the image.
	01234 {// the number on this line is ignored, '{' starts image data
0	 // tab then space between '0' and '/'; only the space is important
1	 // need the space after tab, or line is ignored, boo!
2	XXX          // extra spaces OK
3	   X      // numbers at start are ignored
4	XX  X  // X marks darkened or brightened spots on display, depending
5	  X X  // on display specifics like LCD polarizer.
6	X a #  // Can use other characters, but I like X best.
7	// don't actually need this line; unspecified data same as a space
}   // end of image
@endcode

Except for the width and height, the numbers in the code segment will be ignored. I find them useful for ensuring the image data fits in the specified dimensions. The row numbers at the start of lines are each followed with a tab. The image compiler ignores the tab character, but does not ignore spaces. Multiple tab characters may be used. If a line has neither a space nor an alphabetic character, it will be ignored. If the space before the comment is removed from rows 0 and 1 in the example, then the line marked row 2 will be used as the first row of the image. I'm not happy with this, but don't want to enforce a lack of empty lines and I'd like to keep the parsing code from becoming too complex.

@subsection DUDStoolsBppicOut  Output

The C++ output is a const char array for each image with the same name as the image. It can be used as a header file, but must be included by only one source file. Changing the output to generate a source file and a header file could fix this. The output does not include any namespaces, which would be nice to support, but a namespace can be put around an include statement as a workaround.

The image archive file has the advantage of not requiring a new build to try out a change to an image. A @ref duds::hardware::devices::displays::BppImageArchive "BppImageArchive" object can read in the file and provide shared pointers to the images. Lookups are done by the image name.

*/
